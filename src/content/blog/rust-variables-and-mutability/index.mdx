---
title: 'Rust พื้นฐาน: ทำความเข้าใจตัวแปรและการเปลี่ยนแปลงค่าอย่างละเอียด'
description: 'มาเรียนรู้เรื่องตัวแปรในภาษา Rust อย่างละเอียดครบถ้วน ตั้งแต่ทำไมตัวแปรถึงเป็นแบบไม่เปลี่ยนแปลงโดยค่าเริ่มต้น วิธีการทำให้เปลี่ยนแปลงได้ ค่าคงที่ ไปจนถึงเทคนิคการซ้อนทับตัวแปร'
pubDate: '2025-11-13'
heroImage: './rust-variables-hero.png'
category: 'Programming Languages'
tags: ['Rust', 'Programming', 'Variables', 'Mutability', 'Backend']
featured: true
---

ในบทความนี้ เราจะมาทำความเข้าใจเรื่องพื้นฐานที่สำคัญที่สุดในภาษา Rust นั่นก็คือ "ตัวแปรและการเปลี่ยนแปลงค่า" การเข้าใจหัวข้อนี้เป็นกุญแจสำคัญที่จะทำให้เราเขียนโปรแกรม Rust ได้อย่างปลอดภัยและมีประสิทธิภาพ ไม่ว่าคุณจะเป็นมือใหม่หรือมีประสบการณ์กับภาษาอื่นมาก่อน การทำความเข้าใจแนวคิดนี้จะช่วยให้คุณเขียนโค้ด Rust ได้อย่างถูกต้องและเป็นธรรมชาติ

## Variables and Mutability คืออะไร?

ในภาษาโปรแกรมมิ่งส่วนใหญ่ รวมถึง Rust ด้วย **Variables (ตัวแปร)** คือชื่อที่เราใช้เรียกเก็บข้อมูลประเภทต่างๆ ไว้ในหน่วยความจำของคอมพิวเตอร์ครับ พูดง่ายๆ ก็คือมันเป็นเหมือน "กล่อง" ที่เราตั้งชื่อให้ แล้วเอาค่า (เช่น ตัวเลข ข้อความ) ไปใส่ไว้ในกล่องนั้น

ส่วน **Mutability (การเปลี่ยนแปลงค่าได้)** คือคุณสมบัติของตัวแปรที่บอกว่า "ค่าที่อยู่ในกล่องนั้น สามารถถูกเปลี่ยนเป็นค่าอื่นได้หรือไม่ หลังจากที่ใส่ไปครั้งแรก" ครับ

ใน Rust เรื่องนี้มีความสำคัญมากเป็นพิเศษ เพราะ Rust มีแนวคิดเรื่องความปลอดภัย (Safety) สูง และพยายามควบคุมการเปลี่ยนแปลงข้อมูลเพื่อป้องกันข้อผิดพลาดที่อาจเกิดขึ้นได้

---

## Variables (ตัวแปร) ใน Rust

ในภาษา Rust การประกาศตัวแปรทำได้โดยใช้คีย์เวิร์ด `let` ตามด้วยชื่อตัวแปร เครื่องหมายเท่ากับ `=` และค่าที่เราต้องการกำหนดให้ครับ

```rust
let x = 5; // ประกาศตัวแปรชื่อ x และกำหนดค่า 5 ให้
let greeting = "Hello, Rust!"; // ประกาศตัวแปรชื่อ greeting และกำหนดค่า "Hello, Rust!" ให้
```

### สิ่งที่ต้องรู้เกี่ยวกับตัวแปรใน Rust (เบื้องต้น)

#### 1. Immutability by Default (ไม่เปลี่ยนแปลงค่าได้โดยปริยาย)
นี่คือจุดที่ Rust แตกต่างจากภาษาอื่นๆ ส่วนใหญ่ โดยค่าเริ่มต้นแล้ว ตัวแปรใน Rust จะไม่สามารถเปลี่ยนแปลงค่าได้ (immutable) หลังจากที่เรากำหนดค่าให้มันไปแล้วครับ

<CodeExplainer title="ตัวอย่างที่ผิด (จะเกิด Error)">
```rust
fn main() {
    let x = 5;
    println!("ค่า x ตอนแรก: {}", x); // Output: ค่า x ตอนแรก: 5
    x = 6; // !!! ตรงนี้จะ Error !!! เพราะ x เป็น immutable ไม่สามารถเปลี่ยนค่าได้
    println!("ค่า x ตอนหลัง: {}", x);
}
```
</CodeExplainer>

<InfoBox title="ทำไม Rust ทำแบบนี้?" type="info">
  เหตุผลที่ Rust ทำแบบนี้ก็เพื่อความปลอดภัยครับ การที่ข้อมูลไม่เปลี่ยนไปมาโดยไม่ตั้งใจ ช่วยลดข้อผิดพลาดที่ซับซ้อนในโปรแกรมขนาดใหญ่ได้มาก
</InfoBox>

#### 2. Type Inference (การอนุมานชนิดข้อมูล)
Rust ฉลาดพอที่จะเดาชนิดข้อมูลของตัวแปรได้จากค่าที่เรากำหนดให้ครับ อย่างเช่น `let x = 5;` Rust จะรู้เองว่า `x` ควรจะเป็นตัวเลขจำนวนเต็ม (integer)

แต่เราก็สามารถระบุชนิดข้อมูลอย่างชัดเจนได้ด้วยเช่นกัน:

```rust
let x: i32 = 5; // ระบุว่า x เป็น integer ขนาด 32 บิต
let greeting: &str = "Hello!"; // ระบุว่า greeting เป็น string slice
```

---

## Mutability (การเปลี่ยนแปลงค่าได้) ใน Rust

ถ้าเราต้องการให้ตัวแปรสามารถเปลี่ยนแปลงค่าได้ เราจะต้องระบุอย่างชัดเจนโดยใช้คีย์เวิร์ด `mut` (ย่อมาจาก mutable) หลัง `let` ครับ

<CodeExplainer title="ตัวอย่างการใช้ mut">
```rust
fn main() {
    let mut x = 5; // ประกาศตัวแปรชื่อ x ที่สามารถเปลี่ยนแปลงค่าได้ และกำหนดค่า 5
    println!("ค่า x ตอนแรก: {}", x); // Output: ค่า x ตอนแรก: 5
    x = 6; // ✔️ ทำได้! เพราะ x ถูกประกาศให้เป็น mutable
    println!("ค่า x ตอนหลัง: {}", x); // Output: ค่า x ตอนหลัง: 6
}
```
</CodeExplainer>

### ทำไม Rust ต้องบังคับให้เราใช้ `mut`?

การที่ Rust บังคับให้เราใช้ `mut` อย่างชัดเจน มีประโยชน์หลายอย่าง:

<FeatureGrid>
  <FeatureCard title="ความชัดเจน (Clarity)" icon="eye">
    เมื่อเราเห็น <code>let mut</code> เราจะรู้ทันทีว่าตัวแปรนี้มีโอกาสที่ค่าจะเปลี่ยนไป ซึ่งช่วยให้เราเข้าใจการไหลของข้อมูลในโปรแกรมได้ง่ายขึ้น
  </FeatureCard>
  <FeatureCard title="ความปลอดภัย (Safety)" icon="shield-check">
    การจำกัดว่าเฉพาะตัวแปรที่จำเป็นเท่านั้นที่เปลี่ยนค่าได้ ช่วยป้องกันการเปลี่ยนแปลงข้อมูลโดยไม่ตั้งใจ ลดบั๊ก และทำให้โค้ดมีความน่าเชื่อถือมากขึ้น
  </FeatureCard>
  <FeatureCard title="ประสิทธิภาพ (Performance)" icon="bolt">
    ในบางกรณี การที่ Rust รู้ว่าข้อมูลจะไม่เปลี่ยนแปลง ช่วยให้คอมไพเลอร์สามารถทำการ Optimization (การปรับปรุงโค้ดให้ทำงานได้เร็วขึ้น) ได้ดีขึ้น
  </FeatureCard>
</FeatureGrid>

---

## Constants (ค่าคงที่) ใน Rust

นอกจากตัวแปรแล้ว Rust ยังมี **Constants (ค่าคงที่)** อีกด้วยครับ ค่าคงที่เป็นข้อมูลที่ไม่สามารถเปลี่ยนแปลงค่าได้เลยตลอดอายุของโปรแกรม และต้องระบุชนิดข้อมูลอย่างชัดเจนเสมอ

### ข้อแตกต่างที่สำคัญระหว่าง `let` และ `const`:

1.  **ไม่ใช้ `mut`:** ค่าคงที่ไม่สามารถเป็น `mut` ได้อยู่แล้ว เพราะมันไม่เคยเปลี่ยนค่า
2.  **ประกาศด้วย `const`:** ใช้คีย์เวิร์ด `const` ในการประกาศ
3.  **ชื่อต้องเป็นตัวพิมพ์ใหญ่ทั้งหมด (Screaming Snake Case):** เป็นธรรมเนียมปฏิบัติเพื่อให้แยกแยะค่าคงที่ออกจากตัวแปรปกติได้ง่าย เช่น `MAX_POINTS`, `PI`
4.  **ต้องระบุชนิดข้อมูลเสมอ:** Rust ไม่สามารถอนุมานชนิดข้อมูลของค่าคงที่ได้
5.  **กำหนดค่าเป็น Expression ที่รู้ผลตั้งแต่ Compile Time:** ค่าที่กำหนดให้ `const` ต้องเป็นค่าที่สามารถคำนวณได้ตั้งแต่ตอนคอมไพล์โปรแกรม (compile time) ไม่ใช่ตอนรันโปรแกรม (run time) เช่น `const PI: f64 = 3.14159;` หรือ `const TWO_HOURS_IN_SECONDS: u32 = 2 * 60 * 60;`

```rust
const MAX_POINTS: u32 = 100_000; // ค่าคงที่ที่ชื่อ MAX_POINTS, ชนิดข้อมูล u32, ค่า 100,000
const PI: f64 = 3.14159;         // ค่าคงที่ที่ชื่อ PI, ชนิดข้อมูล f64, ค่า 3.14159

fn main() {
    println!("คะแนนสูงสุดที่อนุญาต: {}", MAX_POINTS);
    println!("ค่า Pi: {}", PI);
    // MAX_POINTS = 200_000; // !!! ตรงนี้จะ Error !!! เพราะค่าคงที่เปลี่ยนไม่ได้
}
```

---

## Shadowing (การบังเงา)

Rust มีแนวคิดที่เรียกว่า **Shadowing (การบังเงา)** ซึ่งไม่ใช่การเปลี่ยนแปลงค่าตัวแปร แต่เป็นการ "ประกาศตัวแปรใหม่ที่มีชื่อซ้ำกับตัวแปรเดิม" ครับ ตัวแปรใหม่นี้จะ "บังเงา" ตัวแปรเก่าไป ทำให้ตัวแปรเก่าไม่สามารถเข้าถึงได้อีกใน Scope นั้นๆ

### ข้อแตกต่างจาก `mut`:

*   `mut` คือการเปลี่ยนค่าใน "กล่องเดิม"
*   Shadowing คือการสร้าง "กล่องใหม่" ที่มีชื่อเดียวกัน ทำให้กล่องเก่าถูกซ่อนไป

<CodeExplainer title="ตัวอย่าง Shadowing และ Scope">
```rust
fn main() {
    let x = 5; // ตัวแปร x ตัวแรก ค่า 5
    let x = x + 1; // ประกาศตัวแปร x "ใหม่" โดยใช้ค่าจาก x ตัวแรก + 1
                   // ตอนนี้ x ตัวแรก (ค่า 5) ถูกบังเงาไปแล้ว
                   // x ตัวใหม่ (ค่า 6) เข้ามาแทนที่
    {
        let x = x * 2; // ใน scope นี้ มีตัวแปร x "ใหม่" อีกตัว ที่มีค่าเป็น (x ตัวนอก * 2) = 12
        println!("ค่า x ใน scope ภายใน: {}", x); // Output: ค่า x ใน scope ภายใน: 12
    }
    println!("ค่า x ใน scope ภายนอก: {}", x); // Output: ค่า x ใน scope ภายนอก: 6
                                              // x ใน scope ภายใน (ค่า 12) ไม่ส่งผลต่อ x ตัวนี้
}
```
</CodeExplainer>

### ประโยชน์ของ Shadowing:

1.  **เปลี่ยนชนิดข้อมูลได้:** ตัวแปรใหม่สามารถมีชนิดข้อมูลที่แตกต่างจากตัวแปรเดิมได้ (ซึ่ง `mut` ทำไม่ได้)
    ```rust
    let spaces = "   "; // spaces เป็น &str (ข้อความ)
    let spaces = spaces.len(); // spaces เป็น usize (จำนวนเต็ม)
    println!("จำนวนช่องว่าง: {}", spaces); // Output: จำนวนช่องว่าง: 3
    ```
2.  **นำชื่อตัวแปรกลับมาใช้ซ้ำ:** บางครั้งเรามีค่าตั้งต้นที่เราต้องการประมวลผลต่อ และเก็บผลลัพธ์ไว้ในชื่อเดิม ซึ่งทำให้โค้ดอ่านง่ายขึ้น

---

## เจาะลึก: "เปลี่ยนชนิดได้?" (Type Change)

ใน Rust เมื่อเราประกาศตัวแปรขึ้นมา สิ่งสำคัญคือตัวแปรนั้นจะมี **ชนิดข้อมูล (Data Type)** กำหนดไว้ตั้งแต่แรก และชนิดข้อมูลนั้นจะ **คงที่ (static)** ตลอดอายุของตัวแปรนั้นครับ

*   เช่น `let x = 5;` Rust จะอนุมานว่า `x` เป็นชนิดตัวเลขจำนวนเต็ม (เช่น `i32`)
*   `let name = "Alice";` Rust จะอนุมานว่า `name` เป็นชนิดข้อความ (`&str`)

เมื่อชนิดข้อมูลถูกกำหนดแล้ว ตัวแปรนั้นจะไม่สามารถเปลี่ยนชนิดข้อมูลได้โดยตรง

### กรณีของ `let mut` (Mutable Variable)

เมื่อเราใช้ `let mut` สิ่งที่เราทำคือการอนุญาตให้ **ค่า (value)** ที่อยู่ในตัวแปรนั้นถูกเปลี่ยนแปลงได้ แต่ **ชนิดข้อมูล (data type)** ของตัวแปรนั้นยังคงเดิมครับ

<CodeExplainer title="let mut เปลี่ยนค่าได้ แต่เปลี่ยน Type ไม่ได้">
```rust
fn main() {
    let mut number = 5; // Rust อนุมานว่า number เป็น i32 (integer 32-bit)
    println!("number: {}", number);
    // Output: number: 5

    number = 10; // เปลี่ยนค่าจาก 5 เป็น 10
    println!("number: {}", number);
    // Output: number: 10 (ชนิดยังคงเป็น i32 เหมือนเดิม)

    // number = "hello"; // !!! ERROR !!!
    // Rust จะฟ้องว่าเราพยายามกำหนดค่าชนิด String ให้กับตัวแปรที่มีชนิดเป็น Integer
    // Expected i32, found &str
    // number = "hello";
    //          ^^^^^^^ expected `i32`, found `&str`
}
```
</CodeExplainer>

จากตัวอย่างจะเห็นว่า `let mut` อนุญาตให้เราเปลี่ยนค่า `5` เป็น `10` ได้ แต่ชนิดข้อมูลของ `number` ยังคงเป็น `i32` เหมือนเดิม เราไม่สามารถเปลี่ยนให้ `number` กลายเป็น `&str` ได้โดยตรงครับ เพราะมันคือ "กล่องเดิม" ที่ถูกออกแบบมาเพื่อเก็บ `i32` เท่านั้น

### กรณีของ Shadowing (`let x = ...`)

Shadowing ไม่ได้เป็นการเปลี่ยนค่าในตัวแปรเดิม แต่เป็นการประกาศตัวแปร **"ใหม่"** ที่มีชื่อซ้ำกับตัวแปรเดิม ครับ

เมื่อเราประกาศตัวแปรใหม่ แม้จะใช้ชื่อเดิม Rust ก็จะถือว่านี่คือตัวแปรใหม่เอี่ยม ซึ่งมีชนิดข้อมูลเป็นของตัวเอง และชนิดข้อมูลของตัวแปรใหม่นี้ **สามารถแตกต่างจากตัวแปรเก่าที่ถูกบังเงาไปได้**

<CodeExplainer title="Shadowing เปลี่ยน Type ได้ (เพราะเป็นตัวแปรใหม่)">
```rust
fn main() {
    let spaces = "   "; // ตัวแปร spaces ตัวแรก, ชนิดข้อมูลคือ &str (string slice)
    println!("spaces: '{}'", spaces);
    // Output: spaces: '   '

    // Shadowing: ประกาศตัวแปร "ใหม่" ชื่อ spaces ทับตัวเก่า
    // และกำหนดค่าเป็นความยาวของ string slice ตัวเก่า ซึ่งเป็นจำนวนเต็ม
    let spaces = spaces.len(); // ตัวแปร spaces ตัวที่สอง, ชนิดข้อมูลคือ usize (integer for size)
    println!("spaces: {}", spaces);
    // Output: spaces: 3

    // ถ้าพยายามจะใช้ spaces ตัวแรก (&str) อีก ก็ทำไม่ได้แล้ว เพราะถูกบังเงาไปแล้ว
    // println!("{}", spaces.trim()); // !!! ERROR !!!
    // 'usize' does not have a method named 'trim'
}
```
</CodeExplainer>

จากตัวอย่างจะเห็นว่า:
1.  ตอนแรก `spaces` เป็น `&str` (ชนิดข้อความ)
2.  ต่อมาเราใช้ `let spaces = spaces.len();` นี่คือการสร้างตัวแปร `spaces` ตัวใหม่ ชนิดข้อมูลเป็น `usize` (จำนวนเต็มที่ใช้สำหรับขนาดหรือความยาว)
3.  ตัวแปร `spaces` ตัวแรก (ที่เป็น `&str`) ถูก "บังเงา" (shadowed) ไปแล้ว เราไม่สามารถเข้าถึงมันได้อีกใน scope นี้
4.  ตัวแปร `spaces` ตัวที่สอง (ที่เป็น `usize`) คือตัวที่เราใช้งานอยู่ตอนนี้

นี่คือความหมายของการที่ Shadowing "เปลี่ยนชนิดได้" ครับ มันไม่ได้เปลี่ยนชนิดของตัวแปรเดิม แต่เป็นการสร้างตัวแปรใหม่ที่มีชื่อซ้ำ และตัวแปรใหม่นั้นสามารถมีชนิดข้อมูลที่ต่างจากตัวเก่าได้

<InfoBox title="ทำไม Rust ถึงอนุญาตให้ทำ Shadowing แบบนี้?" type="success">
  การ Shadowing มีประโยชน์ในสถานการณ์ที่เราต้องการเปลี่ยนการตีความหรือแปลงข้อมูลให้เป็นชนิดอื่นในขั้นตอนต่อเนื่องกัน โดยใช้ชื่อตัวแปรเดิมเพื่อความชัดเจนและลดการตั้งชื่อตัวแปรที่แตกต่างกันมากเกินไป

  เช่น หากคุณมี string ที่ต้องการแปลงเป็นตัวเลข:
  <code>let input = "42";</code>
  <code>let input: i32 = input.trim().parse().expect("ไม่ใช่ตัวเลข!");</code>

  แทนที่จะต้องตั้งชื่อว่า <code>input_str</code> แล้วก็ <code>input_num</code> เราสามารถใช้ <code>input</code> ซ้ำได้เลย ทำให้โค้ดอ่านง่ายขึ้นว่าเรากำลังทำงานกับ "ข้อมูลชุดเดิม" เพียงแต่ "อยู่ในรูปแบบใหม่"
</InfoBox>

---

## สรุปความแตกต่างสำคัญ

<Table>
  <tr slot="head">
    <th>คุณสมบัติ</th>
    <th>let (immutable variable)</th>
    <th>let mut (mutable variable)</th>
    <th>const (constant)</th>
    <th>Shadowing (let x = ...)</th>
  </tr>
  <tr slot="body">
    <td><strong>การเปลี่ยนค่า</strong></td>
    <td>ไม่ได้</td>
    <td>ได้</td>
    <td>ไม่ได้</td>
    <td>สร้างตัวแปรใหม่ที่มีชื่อซ้ำ</td>
  </tr>
  <tr slot="body">
    <td><strong>การประกาศ</strong></td>
    <td><code>let name = value;</code></td>
    <td><code>let mut name = value;</code></td>
    <td><code>const NAME: Type = value;</code></td>
    <td><code>let name = new_value;</code></td>
  </tr>
  <tr slot="body">
    <td><strong>ต้องระบุชนิด?</strong></td>
    <td>ไม่จำเป็น (Rust อนุมานได้)</td>
    <td>ไม่จำเป็น (Rust อนุมานได้)</td>
    <td>จำเป็น</td>
    <td>ไม่จำเป็น (Rust อนุมานได้)</td>
  </tr>
  <tr slot="body">
    <td><strong>ชื่อตัวแปร</strong></td>
    <td>camelCase หรือ snake_case</td>
    <td>camelCase หรือ snake_case</td>
    <td>SCREAMING_SNAKE_CASE (ธรรมเนียม)</td>
    <td>camelCase หรือ snake_case</td>
  </tr>
  <tr slot="body">
    <td><strong>เวลาที่ค่าถูกกำหนด</strong></td>
    <td>Run Time (ส่วนใหญ่)</td>
    <td>Run Time</td>
    <td>Compile Time</td>
    <td>Run Time</td>
  </tr>
  <tr slot="body">
    <td><strong>เปลี่ยนชนิดได้?</strong></td>
    <td>ไม่ได้</td>
    <td>ไม่ได้</td>
    <td>ไม่ได้</td>
    <td>ได้</td>
  </tr>
  <tr slot="body">
    <td><strong>วัตถุประสงค์หลัก</strong></td>
    <td>เก็บค่าที่ไม่เปลี่ยน</td>
    <td>เปลี่ยน ค่า ในตัวแปรเดิม</td>
    <td>ค่าคงที่ตลอดโปรแกรม</td>
    <td>สร้าง ตัวแปรใหม่ ที่มีชื่อซ้ำ</td>
  </tr>
</Table>

หวังว่าบทความนี้จะช่วยให้คุณเข้าใจเรื่อง Variables, Mutability, Constants และ Shadowing ใน Rust ได้อย่างถ่องแท้และชัดเจนนะครับ
