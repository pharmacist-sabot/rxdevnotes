---
title: 'เริ่มต้นกับ Haskell: EP.2 ลงมือปฏิบัติ'
description: 'เริ่มต้นลงมือปฏิบัติ มาลองใช้งาน GHCi ซึ่งเป็นโหมดโต้ตอบของ Haskell เพื่อทำความเข้าใจกับการคำนวณพื้นฐาน, Boolean, และวิธีเรียกใช้ฟังก์ชันแบบ prefix และ infix'
pubDate: '2025-10-17'
heroImage: '/blog-placeholder-7.png'
category: 'Programming Languages'
tags: ['Haskell', 'Functional Programming', 'GHCi', 'Beginner']
featured: false
---

import InfoBox from '../../components/InfoBox.astro';
import CodeExplainer from '../../components/CodeExplainer.astro';

## Ready, set, go!

เอาล่ะครับ มาเริ่มกันเลย ถ้าคุณเป็นคนที่ไม่ชอบอ่านบทนำและข้ามมันไป ผมแนะนำให้อย่างน้อยกลับไปอ่าน **ส่วนสุดท้ายของบทนำ** นะครับ เพราะมันอธิบายว่าคุณต้องมีอะไรบ้างเพื่อที่จะทำตามบทเรียนนี้ และเราจะโหลดฟังก์ชันกันอย่างไร

สิ่งแรกที่เราจะทำคือการรันโหมดโต้ตอบ (interactive mode) ของ GHC และเรียกใช้ฟังก์ชันบางอย่างเพื่อให้คุ้นเคยกับ Haskell เบื้องต้น เปิด Terminal ของคุณขึ้นมาแล้วพิมพ์ `ghci` คุณจะได้รับการต้อนรับประมาณนี้

```bash
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
ghci>
```

ยินดีด้วยครับ ตอนนี้คุณเข้ามาอยู่ใน GHCi แล้ว

### การคำนวณเลขเบื้องต้น

มาลองคำนวณเลขง่ายๆ กันดูครับ

```bash
ghci> 2 + 15
17
ghci> 49 * 100
4900
ghci> 1892 - 1472
420
ghci> 5 / 2
2.5
```

ค่อนข้างตรงไปตรงมานะครับ เรายังสามารถใช้เครื่องหมายคำนวณหลายๆ ตัวในบรรทัดเดียวกันได้ และกฎลำดับความสำคัญ (precedence rules) ที่เราคุ้นเคยก็ยังคงใช้ได้เหมือนเดิม เราสามารถใช้วงเล็บเพื่อกำหนดลำดับความสำคัญให้ชัดเจนหรือเพื่อเปลี่ยนแปลงมันได้

```bash
ghci> (50 * 100) - 4999
1
ghci> 50 * 100 - 4999
1
ghci> 50 * (100 - 4999)
-244950
```

<InfoBox title="ข้อควรระวัง: เลขติดลบ" type="warning">
  มีข้อควรระวังเล็กน้อยเกี่ยวกับการสร้างเลขติดลบครับ ถ้าเราต้องการเลขติดลบ ทางที่ดีที่สุดคือการใส่วงเล็บครอบไว้เสมอ การพิมพ์ `5 * -3` จะทำให้ GHCi ต่อว่าคุณ แต่ถ้าพิมพ์ `5 * (-3)` จะทำงานได้ปกติครับ
</InfoBox>

### พีชคณิตแบบบูลีน (Boolean Algebra)

เรื่อง Boolean ก็ตรงไปตรงมาเช่นกัน อย่างที่คุณน่าจะรู้ `&&` หมายถึง **AND**, `||` หมายถึง **OR** และ `not` ใช้เพื่อสลับค่า `True` หรือ `False`

```bash
ghci> True && False
False
ghci> True && True
True
ghci> False || True
True
ghci> not False
True
ghci> not (True && True)
False
```

### การทดสอบความเท่ากัน

การทดสอบว่าค่าสองค่าเท่ากันหรือไม่ ทำได้ดังนี้ครับ (`/=` หมายถึง "ไม่เท่ากับ")

```bash
ghci> 5 == 5
True
ghci> 1 == 0
False
ghci> 5 /= 5
False
ghci> 5 /= 4
True
ghci> "hello" == "hello"
True
```

แล้วถ้าเราลองทำ `5 + "llama"` หรือ `5 == True` ล่ะ? ถ้าเราลองคำสั่งแรก เราจะเจอข้อความ Error ที่น่ากลัวมาก

<CodeExplainer title="Error! เมื่อชนิดข้อมูลไม่ตรงกัน">
<p>
เมื่อเราพยายามบวกเลขกับข้อความ GHCi จะแจ้งเตือนเราทันที
</p>
<pre><code>
• No instance for (Num String) arising from a use of ‘+’
• In the expression: 5 + "llama"
  In an equation for ‘it’: it = 5 + "llama"
</code></pre>
<p>
สิ่งที่ GHCi กำลังบอกเราก็คือ `"llama"` ไม่ใช่ตัวเลข ดังนั้นมันจึงไม่รู้วิธีที่จะนำไปบวกกับ 5 และถึงแม้ว่ามันจะไม่ใช่ `"llama"` แต่เป็น `"four"` หรือ `"4"` Haskell ก็ยังไม่ถือว่ามันเป็นตัวเลขอยู่ดีครับ เครื่องหมาย `+` คาดหวังว่าค่าทั้งสองข้างของมันจะเป็นตัวเลข
</p>
<p>
ในทำนองเดียวกัน ถ้าเราพยายามทำ `True == 5` GHCi ก็จะบอกเราว่าชนิดข้อมูลไม่ตรงกัน (types don't match) ในขณะที่ `+` จะทำงานได้กับสิ่งที่ถือว่าเป็นตัวเลขเท่านั้น แต่ `==` จะทำงานได้กับของสองสิ่งที่สามารถเปรียบเทียบกันได้ แต่ข้อแม้คือ **ของทั้งสองสิ่งนั้นต้องเป็นชนิดเดียวกัน** คุณไม่สามารถเปรียบเทียบแอปเปิ้ลกับส้มได้ เราจะมาดูเรื่องชนิดข้อมูล (Types) กันละเอียดขึ้นในภายหลัง
</p>
</CodeExplainer>

<InfoBox title="เกร็ดความรู้">
  คุณสามารถทำ `5 + 4.0` ได้ เพราะเลข `5` นั้นฉลาดพอที่จะทำตัวเป็นได้ทั้งเลขจำนวนเต็ม (integer) หรือเลขทศนิยม (floating-point) ก็ได้ แต่ `4.0` ไม่สามารถทำตัวเป็นเลขจำนวนเต็มได้ ดังนั้น `5` จึงเป็นฝ่ายที่ต้องปรับตัว
</InfoBox>

### ขอแนะนำให้รู้จักกับ: ฟังก์ชัน!

คุณอาจจะไม่รู้ตัว แต่เราได้ใช้ฟังก์ชันกันมาตลอดเลยนะครับ ตัวอย่างเช่น `*` คือฟังก์ชันที่รับตัวเลขสองตัวแล้วนำมาคูณกัน อย่างที่คุณเห็น เราเรียกใช้มันโดยการวางมันไว้ระหว่างตัวเลขสองตัว เราเรียกฟังก์ชันแบบนี้ว่า **ฟังก์ชัน Infix (infix function)** แต่ฟังก์ชันส่วนใหญ่ที่ไม่ได้ใช้กับตัวเลขจะเป็น **ฟังก์ชัน Prefix (prefix function)** เรามาดูกันเลยครับ

ฟังก์ชันโดยทั่วไปแล้วจะเป็นแบบ Prefix ดังนั้นจากนี้ไปเราจะไม่อธิบายซ้ำ แต่จะถือว่ามันเป็น Prefix โดยปริยาย ในภาษาโปรแกรมเชิงคำสั่งส่วนใหญ่ เราเรียกใช้ฟังก์ชันโดยการเขียนชื่อฟังก์ชันตามด้วยวงเล็บที่บรรจุพารามิเตอร์ ซึ่งมักจะคั่นด้วยเครื่องหมายจุลภาค

**แต่ใน Haskell เราเรียกใช้ฟังก์ชันโดยการเขียนชื่อฟังก์ชัน เว้นวรรค แล้วตามด้วยพารามิเตอร์ ซึ่งคั่นกันด้วยการเว้นวรรค**

เริ่มต้นด้วยการเรียกฟังก์ชันที่น่าเบื่อที่สุดใน Haskell กันครับ

```bash
ghci> succ 8
9
```

ฟังก์ชัน `succ` (ย่อมาจาก successor) จะรับค่าใดๆ ก็ตามที่มี "ตัวถัดไป" ที่ถูกนิยามไว้ และจะคืนค่าตัวถัดไปนั้นกลับมา อย่างที่คุณเห็น เราแค่คั่นชื่อฟังก์ชันกับพารามิเตอร์ด้วยการเว้นวรรค

การเรียกฟังก์ชันที่มีหลายพารามิเตอร์ก็ง่ายเช่นกัน ฟังก์ชัน `min` และ `max` รับของสองสิ่งที่สามารถจัดลำดับได้ (เช่น ตัวเลข!) `min` จะคืนค่าที่น้อยกว่า และ `max` จะคืนค่าที่มากกว่า ลองดูด้วยตัวคุณเอง:

```bash
ghci> min 9 10
9
ghci> max 100 101
101
```

**การเรียกใช้ฟังก์ชัน (Function application) มีลำดับความสำคัญสูงสุด** ซึ่งหมายความว่าสองคำสั่งนี้ให้ผลลัพธ์เหมือนกัน:

```bash
ghci> succ 9 + max 5 4 + 1
16
ghci> (succ 9) + (max 5 4) + 1
16
```

อย่างไรก็ตาม ถ้าเราต้องการหา "ตัวถัดไป" ของผลคูณระหว่าง 9 กับ 10 เราไม่สามารถเขียน `succ 9 * 10` ได้ เพราะมันจะไปหาตัวถัดไปของ 9 ก่อน (ซึ่งคือ 10) แล้วค่อยนำไปคูณกับ 10 ผลลัพธ์ที่ได้จึงเป็น 100 เราจะต้องเขียนเป็น `succ (9 * 10)` เพื่อให้ได้ผลลัพธ์ที่ถูกต้องคือ 91

ถ้าฟังก์ชันรับพารามิเตอร์สองตัว เรายังสามารถเรียกมันแบบ Infix ได้โดยการใช้เครื่องหมาย backtick ( ` ` ) ครอบชื่อฟังก์ชัน ตัวอย่างเช่น ฟังก์ชัน `div` รับเลขจำนวนเต็มสองตัวและทำการหารแบบปัดเศษ การเขียน `div 92 10` จะได้ผลลัพธ์เป็น 9 แต่เมื่อเราเรียกใช้แบบนี้ อาจจะเกิดความสับสนได้ว่าตัวไหนคือตัวตั้งตัวไหนคือตัวหาร ดังนั้นเราจึงสามารถเรียกใช้แบบ Infix โดยเขียนเป็น ``92 `div` 10`` ซึ่งจะทำให้เข้าใจได้ชัดเจนขึ้นมาก

<InfoBox title="ข้อควรจำ: วงเล็บ vs. เว้นวรรค" type="warning">
  หลายคนที่มาจากภาษา Imperative มักจะยึดติดกับความคิดที่ว่าวงเล็บใช้สำหรับการเรียกใช้ฟังก์ชัน เช่นในภาษา C คุณจะใช้ `foo()`, `bar(1)` หรือ `baz(3, "haha")`
  
  อย่างที่เราบอกไป ใน Haskell เราใช้การ **เว้นวรรค** สำหรับการเรียกใช้ฟังก์ชัน ดังนั้นฟังก์ชันเหล่านั้นใน Haskell จะกลายเป็น `foo`, `bar 1` และ `baz 3 "haha"`
  
  ดังนั้น ถ้าคุณเห็นโค้ดอย่าง `bar (bar 3)` มันไม่ได้หมายความว่าฟังก์ชัน `bar` ถูกเรียกโดยมี `bar` และ `3` เป็นพารามิเตอร์ แต่มันหมายความว่า **เราเรียกฟังก์ชัน `bar` ด้วยพารามิเตอร์ `3` ก่อน เพื่อให้ได้ผลลัพธ์เป็นตัวเลขบางอย่าง จากนั้นเราจึงเรียกฟังก์ชัน `bar` อีกครั้งด้วยตัวเลขนั้น**
  
  ซึ่งในภาษา C จะเทียบเท่ากับ `bar(bar(3))` ครับ
</InfoBox>