---
title: 'เริ่มต้นกับ Haskell: EP.1 บทนำ'
description: "แปลและเรียบเรียงจากบทนำของ 'Learn You a Haskell for Great Good!' เพื่อให้โปรแกรมเมอร์ที่มีประสบการณ์กับภาษาอย่าง C, Java, Python ได้เข้าใจแก่นของ Functional Programming ผ่าน Haskell"
pubDate: '2025-10-13'
heroImage: '/images/common/blog-placeholder-6.png'
category: 'Programming Languages'
tags: ['Haskell', 'Functional Programming', 'Beginner'] 
featured: true
---

<InfoBox title="ที่มาและเครดิต" type="info">
  บทความนี้เป็นการแปลและเรียบเรียงเนื้อหาจากบทนำของหนังสือ **"Learn You a Haskell for Great Good!"** โดย **Miran Lipovača** ซึ่งเป็นหนึ่งในแหล่งเรียนรู้ Haskell ที่ดีที่สุดสำหรับผู้เริ่มต้น ผมได้ปรับสำนวนให้อ่านง่ายในบริบทภาษาไทย แต่ยังคงเนื้อหาและเจตนารมณ์ของต้นฉบับไว้ 100% เพื่อเป็นอีกหนึ่งช่องทางให้คนไทยได้เข้าถึงความรู้ที่ยอดเยี่ยมนี้  
  
  ขอขอบคุณผู้เขียนสำหรับผลงานอันล้ำค่า คุณสามารถอ่านต้นฉบับภาษาอังกฤษได้ฟรีที่ [learnyouahaskell.com](http://learnyouahaskell.com/introduction).
</InfoBox>

## เกี่ยวกับบทความนี้

ยินดีต้อนรับสู่ **Learn You a Haskell for Great Good!** ครับ ถ้าคุณกำลังอ่านบทความนี้อยู่ ก็มีความเป็นไปได้สูงว่าคุณอยากจะเรียนรู้ภาษา Haskell

ใช่แล้วครับ คุณมาถูกที่แล้ว แต่ก่อนอื่น เรามาคุยกันเรื่องบทความนี้กันสักหน่อย

ผมตัดสินใจเขียนบทความนี้ขึ้นมาเพราะอยากจะทำให้ความรู้เรื่อง Haskell ของตัวเองแข็งแกร่งขึ้น และเพราะผมคิดว่าผมน่าจะช่วยให้คนใหม่ๆ ได้เรียนรู้ Haskell ในมุมมองของผมได้ มีบทเรียน Haskell ดีๆ มากมายอยู่บนอินเทอร์เน็ต ตอนที่ผมเริ่มเรียน Haskell ผมไม่ได้เรียนจากแหล่งข้อมูลเดียว วิธีที่ผมเรียนคือการอ่านบทเรียนและบทความต่างๆ หลายๆ ที่ เพราะแต่ละที่ก็อธิบายบางเรื่องในวิธีที่แตกต่างกันออกไป การได้เรียนรู้จากหลายๆ แหล่งข้อมูลช่วยให้ผมสามารถปะติดปะต่อชิ้นส่วนต่างๆ เข้าด้วยกัน และในที่สุดทุกอย่างก็ลงตัว

ดังนั้น นี่คือความพยายามของผมที่จะเพิ่มแหล่งข้อมูลดีๆ สำหรับการเรียน Haskell อีกหนึ่งชิ้น เพื่อให้คุณมีโอกาสมากขึ้นที่จะเจอแหล่งข้อมูลที่ถูกใจ

บทความนี้มุ่งเป้าไปที่คนที่มีประสบการณ์เขียนโปรแกรมเชิงคำสั่ง (Imperative) มาก่อน (เช่น C, C++, Java, Python) แต่ยังไม่เคยเขียนโปรแกรมเชิงฟังก์ชัน (Functional) มาก่อน (เช่น Haskell, ML, OCaml) แต่ผมก็เชื่อว่าถึงแม้คุณจะไม่มีประสบการณ์เขียนโปรแกรมที่โดดเด่นอะไรเลย คนฉลาดอย่างคุณก็น่าจะติดตามและเรียนรู้ Haskell ได้สบายๆ

<InfoBox title="ติดปัญหา? ถามได้เลย!" type="success">
  ช่องแชท **#haskell** บนเน็ตเวิร์ค **Libera.Chat** เป็นที่ที่ดีมากสำหรับถามคำถามเมื่อคุณรู้สึกติดขัด ผู้คนที่นั่นใจดี อดทน และพร้อมที่จะช่วยเหลือและให้ความเข้าใจกับมือใหม่เสมอ
</InfoBox>

ผมเคยล้มเหลวกับการเรียน Haskell มาแล้วประมาณ 2 ครั้งก่อนที่จะเข้าใจมันจริงๆ เพราะทุกอย่างมันดูแปลกประหลาดไปหมดและผมเข้าไม่ถึงมัน แต่พอวันหนึ่งที่มัน "คลิก" และผ่านกำแพงแรกไปได้ ที่เหลือก็ราบรื่นมากครับ สิ่งที่ผมพยายามจะบอกก็คือ: Haskell นั้นยอดเยี่ยมมาก และถ้าคุณสนใจการเขียนโปรแกรม คุณควรจะเรียนมัน ถึงแม้ในตอนแรกมันจะดูแปลกๆ ก็ตาม การเรียน Haskell ก็เหมือนกับการเรียนเขียนโปรแกรมครั้งแรก—มันสนุก มันบังคับให้เราคิดต่าง ซึ่งนั่นก็นำเราไปสู่หัวข้อถัดไป...

## แล้ว Haskell คืออะไร?

**Haskell เป็นภาษาโปรแกรมมิ่งเชิงฟังก์ชันอย่างแท้จริง (purely functional programming language)**

ในภาษาโปรแกรมเชิงคำสั่ง (Imperative) คุณสั่งให้คอมพิวเตอร์ทำงานโดยการกำหนดลำดับของงานต่างๆ แล้วให้มันทำตามลำดับนั้น ขณะที่ทำงาน มันสามารถเปลี่ยนแปลง "สถานะ" (state) ได้ เช่น คุณกำหนดให้ตัวแปร `a` เป็น 5 แล้วทำอะไรบางอย่าง จากนั้นก็เปลี่ยนค่า `a` ไปเป็นอย่างอื่น คุณมีโครงสร้างควบคุมการไหลของโปรแกรม (control flow) เพื่อสั่งให้ทำบางอย่างซ้ำๆ

แต่ในโปรแกรมมิ่งเชิงฟังก์ชันอย่างแท้จริง คุณไม่ได้ "สั่ง" ให้คอมพิวเตอร์ทำอะไร แต่คุณ "บอก" มันว่าสิ่งต่างๆ **คือ**อะไร เช่น แฟกทอเรียลของจำนวนหนึ่งคือผลคูณของเลขทั้งหมดตั้งแต่ 1 ถึงเลขนั้น, ผลรวมของลิสต์คือตัวเลขตัวแรกบวกกับผลรวมของตัวเลขที่เหลือ เป็นต้น คุณแสดงสิ่งเหล่านี้ออกมาในรูปแบบของฟังก์ชัน

คุณไม่สามารถกำหนดค่าให้ตัวแปรแล้วมาเปลี่ยนทีหลังได้ ถ้าคุณบอกว่า `a` คือ 5 คุณจะมาบอกทีหลังว่ามันเป็นอย่างอื่นไม่ได้ เพราะคุณเพิ่งบอกไปเองว่ามันคือ 5 (จะโกหกเหรอ?) ดังนั้น ในภาษาเชิงฟังก์ชันแท้ๆ **ฟังก์ชันจะไม่มีผลข้างเคียง (side effects)** สิ่งเดียวที่ฟังก์ชันทำได้คือคำนวณอะไรบางอย่างแล้วคืนค่ากลับมาเป็นผลลัพธ์ ตอนแรกอาจจะฟังดูเหมือนเป็นข้อจำกัด แต่จริงๆ แล้วมันมีข้อดีที่ยอดเยี่ยมมาก: **ถ้าฟังก์ชันถูกเรียกสองครั้งด้วยพารามิเตอร์เดียวกัน มันรับประกันได้เลยว่าจะคืนค่าผลลัพธ์เดิมเสมอ** สิ่งนี้เรียกว่า **"Referential Transparency"** ซึ่งไม่เพียงแต่ช่วยให้คอมไพเลอร์สามารถวิเคราะห์พฤติกรรมของโปรแกรมได้เท่านั้น แต่ยังช่วยให้เราสามารถอนุมาน (และแม้กระทั่งพิสูจน์) ได้ว่าฟังก์ชันนั้นถูกต้อง แล้วนำไปสร้างฟังก์ชันที่ซับซ้อนขึ้นโดยการนำฟังก์ชันง่ายๆ มาประกอบกัน

## แล้ว Haskell มีดีอะไร?

<FeatureGrid>
  <FeatureCard title="Lazy (ขี้เกียจ)" icon="pause-circle">
    Haskell จะไม่ประมวลผลฟังก์ชันหรือคำนวณอะไรเลยจนกว่าจะถูก "บังคับ" ให้แสดงผลลัพธ์จริงๆ ซึ่งเข้ากันได้ดีกับ Referential Transparency และทำให้เราคิดถึงโปรแกรมในฐานะ "ชุดของการแปลงข้อมูล" (series of transformations on data) มันยังทำให้เราทำสิ่งที่เจ๋งๆ อย่างโครงสร้างข้อมูลแบบไม่สิ้นสุด (infinite data structures) ได้ด้วย สมมติคุณมีลิสต์ `xs = [1,2,3,4,5,6,7,8]` และฟังก์ชัน `doubleMe` ที่คูณทุกตัวด้วย 2 ถ้าเราทำ `doubleMe(doubleMe(doubleMe(xs)))` ในภาษา Imperative มันอาจจะวิ่งผ่านลิสต์ 3 รอบและสร้างลิสต์ใหม่ 3 ครั้ง แต่ในภาษา Lazy อย่าง Haskell มันจะแค่บอกว่า "โอเคๆ เดี๋ยวค่อยทำ" จนกว่าคุณจะต้องการผลลัพธ์จริงๆ มันถึงจะวิ่งผ่านลิสต์แค่รอบเดียว และทำเท่าที่จำเป็นเท่านั้น
  </FeatureCard>
  <FeatureCard title="Statically Typed (กำหนดชนิดข้อมูลตอนคอมไพล์)" icon="shield-check">
    ตอนที่คุณคอมไพล์โปรแกรม คอมไพเลอร์จะรู้ว่าโค้ดส่วนไหนคือตัวเลข ส่วนไหนคือข้อความ ซึ่งหมายความว่าข้อผิดพลาดจำนวนมากจะถูกจับได้ตั้งแต่ตอนคอมไพล์ ถ้าคุณพยายามบวกเลขกับข้อความ คอมไพเลอร์จะบ่นทันที Haskell มีระบบชนิดข้อมูล (Type System) ที่ดีมากและมี **Type Inference** ซึ่งหมายความว่าคุณไม่จำเป็นต้องประกาศชนิดข้อมูลให้กับทุกอย่าง เพราะระบบสามารถอนุมานได้เองอย่างชาญฉลาด ถ้าคุณเขียน `a = 5 + 4` คุณไม่ต้องบอก Haskell ว่า `a` เป็นตัวเลข มันคิดเองได้
  </FeatureCard>
    <FeatureCard title="Elegant & Concise (สละสลวยและรัดกุม)" icon="code-bracket-square">
    เพราะ Haskell ใช้แนวคิดระดับสูงมากมาย โปรแกรมที่เขียนด้วย Haskell จึงมักจะสั้นกว่าโปรแกรมที่เขียนด้วยภาษา Imperative และโปรแกรมที่สั้นกว่าก็ดูแลรักษาง่ายกว่าและมีบั๊กน้อยกว่าด้วย
  </FeatureCard>
</FeatureGrid>

<InfoBox title="ความเป็นมาเล็กน้อย">
  Haskell ถูกสร้างโดยกลุ่มคนฉลาด (ระดับ PhDs) โดยเริ่มขึ้นในปี 1987 เมื่อคณะกรรมการนักวิจัยกลุ่มหนึ่งมารวมตัวกันเพื่อออกแบบภาษาสุดเจ๋ง ในปี 2003 Haskell Report ก็ถูกตีพิมพ์ ซึ่งเป็นเอกสารกำหนดเวอร์ชันที่เสถียรของภาษา
</InfoBox>

## สิ่งที่ต้องมีเพื่อเริ่มต้น

**Text editor และ Haskell compiler** คุณน่าจะมี text editor ที่ชอบอยู่แล้ว เราจะไม่เสียเวลากับเรื่องนั้น ในบทความนี้เราจะใช้ **GHC (Glasgow Haskell Compiler)** ซึ่งเป็นคอมไพเลอร์ Haskell ที่ใช้กันแพร่หลายที่สุด วิธีที่ดีที่สุดในการเริ่มต้นคือดาวน์โหลด **GHCup** ซึ่งเป็นเครื่องมือติดตั้ง Haskell ที่แนะนำ

GHC สามารถรับไฟล์ Haskell (ส่วนใหญ่มีนามสกุล `.hs`) แล้วคอมไพล์มันได้ แต่มันก็มี **โหมดโต้ตอบ (interactive mode)** ที่ให้คุณสามารถโต้ตอบกับไฟล์ได้ทันที คุณสามารถเรียกใช้ฟังก์ชันจากไฟล์ที่คุณโหลดเข้ามาแล้วผลลัพธ์จะแสดงขึ้นมาทันที สำหรับการเรียนรู้ นี่เป็นวิธีที่ง่ายและเร็วกว่าการคอมไพล์ใหม่ทุกครั้ง

<InfoBox title="Workflow ประจำวัน" type="success">
  1.  **เปิดโหมดโต้ตอบ** โดยพิมพ์ `ghci` ใน command prompt
  2.  **โหลดฟังก์ชัน** ถ้าคุณมีฟังก์ชันในไฟล์ชื่อ `myfunctions.hs` ให้โหลดเข้ามาด้วยคำสั่ง `:l myfunctions`
  3.  **เล่นกับมัน** ตอนนี้คุณสามารถเรียกใช้ฟังก์ชันต่างๆ และดูผลลัพธ์ได้เลย
  4.  **โหลดซ้ำเมื่อแก้ไข** ถ้าคุณแก้ไขไฟล์ `.hs` ก็แค่รัน `:l myfunctions` อีกครั้ง หรือจะใช้ `:r` ก็ได้ ซึ่งให้ผลเหมือนกันเพราะมันจะโหลดไฟล์ปัจจุบันซ้ำ
</InfoBox>

Workflow ปกติของผมเวลาเขียนโค้ดคือการนิยามฟังก์ชันในไฟล์ `.hs`, โหลดมันเข้ามาใน `ghci`, ลองเล่นกับมัน, แล้วก็กลับไปแก้ไฟล์ `.hs`, โหลดซ้ำ, วนไปเรื่อยๆ และนี่ก็คือวิธีที่เราจะใช้กันในบทความนี้ครับ
