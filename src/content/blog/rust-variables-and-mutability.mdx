---
title: 'Rust พื้นฐาน: ทำความเข้าใจตัวแปรและการเปลี่ยนแปลงค่าอย่างละเอียด'
description: 'มาเรียนรู้เรื่องตัวแปรในภาษา Rust อย่างละเอียดครบถ้วน ตั้งแต่ทำไมตัวแปรถึงเป็นแบบไม่เปลี่ยนแปลงโดยค่าเริ่มต้น วิธีการทำให้เปลี่ยนแปลงได้ ค่าคงที่ ไปจนถึงเทคนิคการซ้อนทับตัวแปร'
pubDate: '2025-11-13'
heroImage: '/blog/rust-variables-hero.png'
category: 'Programming Languages'
tags: ['Rust', 'Programming', 'Variables', 'Mutability', 'Backend']
featured: true
---

ในบทความนี้ เราจะมาทำความเข้าใจเรื่องพื้นฐานที่สำคัญที่สุดในภาษา Rust นั่นก็คือ "ตัวแปรและการเปลี่ยนแปลงค่า" การเข้าใจหัวข้อนี้เป็นกุญแจสำคัญที่จะทำให้เราเขียนโปรแกรม Rust ได้อย่างปลอดภัยและมีประสิทธิภาพ ไม่ว่าคุณจะเป็นมือใหม่หรือมีประสบการณ์กับภาษาอื่นมาก่อน การทำความเข้าใจแนวคิดนี้จะช่วยให้คุณเขียนโค้ด Rust ได้อย่างถูกต้องและเป็นธรรมชาติ

## ตัวแปรใน Rust: ทำไมถึงเปลี่ยนค่าไม่ได้โดยค่าเริ่มต้น?

ลองนึกถึงภาษาโปรแกรมอื่นๆ ที่เราคุ้นเคยกันดี เช่น JavaScript, Python หรือ Java เราสามารถประกาศตัวแปรแล้วเปลี่ยนค่าได้ตลอดเวลาตามที่ต้องการ แต่ใน Rust จะต่างออกไปอย่างสิ้นเชิง ตัวแปรจะเป็นแบบ **ไม่สามารถเปลี่ยนแปลง (immutable)** โดยค่าเริ่มต้น

นี่คือหนึ่งในหลายๆ วิธีที่ Rust "ช่วย" หรือ "ผลักดัน" เราให้เขียนโค้ดที่ปลอดภัยและรองรับการทำงานแบบขนาน (concurrency) ได้ดีขึ้น มันเป็นการออกแบบที่ตั้งใจมาจากประสบการณ์ของนักพัฒนาที่เจอปัญหาจากการเปลี่ยนแปลงค่าโดยไม่ตั้งใจมากมาย

<InfoBox title="ทำไม Rust ถึงออกแบบมาแบบนี้?" type="info">
  การทำให้ตัวแปรไม่เปลี่ยนแปลงโดยค่าเริ่มต้นช่วยลดข้อผิดพลาดจากการเปลี่ยนค่าโดยไม่ตั้งใจ ซึ่งเป็นปัญหาที่พบบ่อยมากในการเขียนโปรแกรม โดยเฉพาะในโปรเจกต์ขนาดใหญ่ที่มีหลายคนมาทำงานร่วมกัน
</InfoBox>

เมื่อเราประกาศตัวแปรแบบไม่เปลี่ยนแปลงแล้ว ค่านั้นจะ "ติด" กับชื่อตัวแปรไปตลอดช่วงชีวิตของมัน ถ้าเราพยายามเปลี่ยนค่า คอมไพเลอร์จะหยุดเราทันที มาลองดูตัวอย่างกันเลยดีกว่า:

<CodeExplainer title="ลองเขียนโค้ดที่จะคอมไพล์ไม่ผ่าน">
```rust
fn main() {
    let x = 5;
    println!("ค่าของ x คือ: {x}");
    x = 6;  // บรรทัดนี้จะทำให้เกิด error
    println!("ค่าของ x คือ: {x}");
}
```
</CodeExplainer>

พอเราลองรันโค้ดนี้ด้วย `cargo run` เราจะเจอข้อความแจ้ง error แบบนี้:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - กำหนดค่าครั้งแรกให้ x
3 |     println!("ค่าของ x คือ: {x}");
4 |     x = 6;
  |     ^^^^^ ไม่สามารถกำหนดค่าให้ตัวแปรที่เปลี่ยนแปลงไม่ได้ซ้ำได้
  |
help: ลองทำให้ตัวแปรนี้เปลี่ยนแปลงได้ดู
  |
2 |     let mut x = 5;
  |         +++
```

<InfoBox title="Error ของ Rust ให้ข้อมูลดีมาก" type="success">
  สังเกตไหมว่า Rust ไม่ได้บอกแค่ว่า error แต่ยังแนะนำวิธีแก้ไขด้วย! ในที่นี้มันบอกให้เราเพิ่ม `mut` หน้าชื่อตัวแปร นี่คือหนึ่งในเหตุผลที่ทำให้การเขียน Rust ไม่น่ากลัวเหมือนที่คนคิด
</InfoBox>

ข้อผิดพลาดนี้เกิดขึ้นเพราะเราพยายามกำหนดค่าใหม่ให้กับตัวแปร `x` ที่เป็นแบบไม่สามารถเปลี่ยนแปลง คอมไพเลอร์ Rust ช่วยเราไว้ตรงนี้ เพราะมันรู้ว่าการเปลี่ยนค่าของตัวแปรที่ไม่ควรเปลี่ยนอาจนำไปสู่บั๊กที่ยากจะตามหาในภายหลัง

## ทำให้ตัวแปรเปลี่ยนแปลงได้ด้วยคีย์เวิร์ด `mut`

ถ้าเราต้องการเปลี่ยนค่าของตัวแปรจริงๆ Rust ก็มีทางออกให้เรา เราแค่เพิ่มคีย์เวิร์ด `mut` (ย่อมาจาก mutable) ไว้ข้างหน้าชื่อตัวแปรก็พอ การทำเช่นนี้ไม่เพียงแต่ทำให้ตัวแปรสามารถเปลี่ยนแปลงได้ แต่ยังสื่อสารถึงความตั้งใจของเราให้คนอื่นที่มาอ่านโค้ดของเรารู้ด้วยว่า "ตัวแปรตัวนี้จะมีการเปลี่ยนค่าในโปรแกรมนะ"

<CodeExplainer title="ตัวอย่างโค้ดที่ทำงานได้">
```rust
fn main() {
    let mut x = 5;
    println!("ค่าของ x คือ: {x}");
    x = 6;
    println!("ค่าของ x คือ: {x}");
}
```
</CodeExplainer>

ตอนนี้โปรแกรมจะทำงานได้ปกติและแสดงผล:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
ค่าของ x คือ: 5
ค่าของ x คือ: 6
```

การใช้ `mut` ไม่ได้แค่ทำให้ตัวแปรเปลี่ยนค่าได้ แต่ยังเป็นการบอกความตั้งใจของเราให้ผู้อ่านโค้ดในอนาคตรู้ว่าส่วนอื่นของโค้ดอาจเปลี่ยนแปลงค่าของตัวแปรนี้ นี่คือแนวทางการเขียนโค้ดที่ดีใน Rust - ให้คอมไพเลอร์ช่วยคุณสื่อสารความตั้งใจของคุณ

<ProsCons>
  <div slot="pros">
    <h4>ข้อดีของตัวแปรแบบไม่เปลี่ยนแปลง (Immutable)</h4>
    <ul>
      <li><strong>ความปลอดภัย:</strong> ลดโอกาสเกิดบั๊กจากการเปลี่ยนค่าโดยไม่ตั้งใจ ซึ่งเป็นปัญหาที่พบบ่อยในโปรแกรมขนาดใหญ่</li>
      <li><strong>การทำงานแบบขนานง่าย:</strong> เมื่อตัวแปรไม่เปลี่ยนแปลง เราสามารถแชร์ข้อมูลระหว่าง thread ต่างๆ ได้โดยไม่ต้องกลัวว่าจะมีใครไปแก้ไขค่า</li>
      <li><strong>อ่านโค้ดง่าย:</strong> ไม่ต้องกังวลว่าค่าของตัวแปรจะเปลี่ยนไปตอนไหน ทำให้การอนุมานโค้ด (reasoning about code) ง่ายขึ้น</li>
      <li><strong>การเพิ่มประสิทธิภาพ:</strong> คอมไพเลอร์สามารถทำ optimization ได้ดีขึ้นเมื่อรู้ว่าค่าจะไม่เปลี่ยน</li>
    </ul>
  </div>
  <div slot="cons">
    <h4>ข้อดีของตัวแปรแบบเปลี่ยนแปลงได้ (Mutable)</h4>
    <ul>
      <li><strong>ความสะดวก:</strong> บางครั้งการเปลี่ยนค่าตัวแปรเดิมสะดวกกว่าการสร้างตัวแปรใหม่ ทำให้โค้ดกระชับขึ้น</li>
      <li><strong>ประสิทธิภาพหน่วยความจำ:</strong> ไม่ต้องสร้างตัวแปรใหม่ทุกครั้งที่ต้องการค่าที่เปลี่ยนไป ซึ่งอาจประหยัดหน่วยความจำในบางกรณี</li>
      <li><strong>ความยืดหยุ่น:</strong> เหมาะกับข้อมูลที่จำเป็นต้องอัปเดตค่าบ่อยๆ เช่น counter, accumulator หรือ state ที่เปลี่ยนแปลงตลอดเวลา</li>
      <li><strong>ความเข้าใจง่ายสำหรับมือใหม่:</strong> คนที่มาจากภาษาอื่นจะคุ้นเคยกับการเปลี่ยนค่าตัวแปรมากกว่า</li>
    </ul>
  </div>
</ProsCons>

## ค่าคงที่ (Constants) คืออะไรและต่างจากตัวแปรอย่างไร?

ค่าคงที่ใน Rust คือค่าที่ผูกกับชื่อและไม่อนุญาตให้เปลี่ยนแปลง มันคล้ายกับตัวแปรแบบไม่เปลี่ยนแปลง แต่มีความแตกต่างกันอยู่หลายประการที่สำคัญมาก:

### ความแตกต่างระหว่าง Constants และ Immutable Variables

1. **การประกาศ:** ค่าคงที่ใช้คีย์เวิร์ด `const` แทน `let`
2. **ประเภทข้อมูล:** ค่าคงที่ต้องระบุประเภทข้อมูลเสมอ (type annotation) ไม่สามารถให้คอมไพเลอร์อนุมานได้
3. **ขอบเขตการใช้งาน:** ค่าคงที่สามารถประกาศได้ในทุก scope รวมถึง global scope (นอกฟังก์ชัน)
4. **ค่าที่กำหนดได้:** ค่าคงที่สามารถตั้งได้เฉพาะค่าคงที่ (constant expression) ที่คำนวณได้ตอนคอมไพล์ ไม่ใช่ค่าที่ต้องรอโปรแกรมทำงานถึงรู้ค่า
5. **การเปลี่ยนแปลง:** ค่าคงที่ไม่สามารถใช้ `mut` ได้เลย มันคือค่าที่ไม่เปลี่ยนแปลงตลอดกาล

<CodeExplainer title="ตัวอย่างการประกาศค่าคงที่">
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

fn main() {
    println!("3 ชั่วโมงมีทั้งหมด {} วินาที", THREE_HOURS_IN_SECONDS);
}
```
</CodeExplainer>

ในตัวอย่างนี้:
- `THREE_HOURS_IN_SECONDS` คือชื่อค่าคงที่
- `u32` คือประเภทข้อมูล (จำนวนเต็ม 32 บิตไม่มีเครื่องหมาย)
- ค่าคือผลของ 60 × 60 × 3 = 10,800 วินาที

สิ่งที่น่าสนใจคือคอมไพเลอร์ Rust สามารถคำนวณนิพจน์ง่ายๆ ตอนคอมไพล์ได้ ทำให้เราสามารถเขียน `60 * 60 * 3` แทนการเขียน `10800` ตรงๆ ซึ่งทำให้โค้ดอ่านง่ายและเข้าใจได้ดีขึ้น

<InfoBox title="การตั้งชื่อค่าคงที่ใน Rust" type="info">
  ใน Rust เรามักจะตั้งชื่อค่าคงที่เป็นตัวพิมพ์ใหญ่ทั้งหมดและใช้ขีดล่างคั่นระหว่างคำ (เรียกว่า SCREAMING_SNAKE_CASE) เช่น `MAX_SCORE`, `PI_VALUE`, `DEFAULT_TIMEOUT`
</InfoBox>

### เมื่อไหร่ควรใช้ Constants?

ค่าคงที่เหมาะสำหรับข้อมูลที่:
- โปรแกรมหลายส่วนต้องใช้ร่วมกัน
- มีค่าคงที่และไม่เปลี่ยนแปลงตลอดการทำงานของโปรแกรม
- ต้องการให้คอมไพเลอร์ตรวจสอบค่าตอนคอมไพล์

ตัวอย่างเช่น:
- ค่าความเร็วแสง: `const SPEED_OF_LIGHT: f64 = 299_792_458.0;`
- คะแนนสูงสุดในเกม: `const MAX_SCORE: u32 = 1000000;`
- อัตราภาษี: `const VAT_RATE: f64 = 0.07;`

<InfoBox title="ประโยชน์ของการใช้ Constants" type="success">
  การใช้ค่าคงที่ช่วยให้เรามีจุดเดียวที่ต้องแก้ไขเมื่อค่าเปลี่ยน ลดความผิดพลาดจากการพิมพ์ผิด และทำให้โค้ดอ่านง่ายขึ้นเพราะใช้ชื่อที่มีความหมายแทนตัวเลขที่ไม่รู้เรื่อง (magic numbers)
</InfoBox>

## การใช้ตัวแปรซ้อนทับ (Shadowing) - เทคนิคที่ทรงพลัง

นี่คือเทคนิคที่น่าสนใจและเป็นเอกลักษณ์ของ Rust เราสามารถประกาศตัวแปรใหม่ด้วยชื่อเดิมได้! นักพัฒนา Rust เรียกสิ่งนี้ว่า "การซ้อนทับ" (shadowing) ซึ่งหมายความว่าตัวแปรที่สองจะ "บัง" ตัวแปรแรก ทำให้คอมไพเลอร์เห็นแต่ตัวแปรที่สองเมื่อใช้ชื่อนั้น

<CodeExplainer title="ตัวอย่างการซ้อนทับตัวแปร">
```rust
fn main() {
    let x = 5;           // x เท่ากับ 5

    let x = x + 1;       // x ตัวใหม่เท่ากับ 6 (ซ้อนทับตัวเก่า)

    {
        let x = x * 2;   // x ในวงเล็บเท่ากับ 12 (ซ้อนทับอีกครั้ง)
        println!("ค่า x ในวงเล็บคือ: {x}");
    }

    println!("ค่า x นอกวงเล็บคือ: {x}");
}
```
</CodeExplainer>

ผลลัพธ์จะเป็น:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
ค่า x ในวงเล็บคือ: 12
ค่า x นอกวงเล็บคือ: 6
```

อธิบายทีละขั้นตอน:
1. ประกาศ `x = 5` - นี่คือตัวแปรแรก
2. สร้าง `x` ตัวใหม่โดยใช้ `let x =` ซึ่งนำค่าเก่ามาบวก 1 → ได้ 6 - นี่คือตัวแปรที่สอง
3. ในวงเล็บ `{}` สร้าง `x` อีกตัวโดยคูณค่าก่อนหน้าด้วย 2 → ได้ 12 - นี่คือตัวแปรที่สาม
4. พอออกจากวงเล็บ `{}` ตัวแปรที่สามหายไป และ `x` กลับไปเป็นตัวแปรที่สองที่มีค่า 6

### Shadowing กับ Mutability ต่างกันยังไง?

นี่คือคำถามสำคัญที่หลายคนสงสัย ทั้งสองอย่างดูเหมือนจะทำงานเหมือนกัน แต่จริงๆ แล้วต่างกันอย่างสิ้นเชิง:

<FeatureGrid>
  <FeatureCard title="Shadowing ต้องใช้ `let` ทุกครั้ง" icon="code-bracket-square">
    การซ้อนทับต้องใช้คีย์เวิร์ด `let` ทุกครั้งที่จะเปลี่ยนค่า ถ้าใช้ผิดจะ error ตอนคอมไพล์ แต่ `mut` ไม่ต้องใช้ `let` ซ้ำ แต่ถ้าใช้ผิดจะทำให้โปรแกรมทำงานผิดแบบไม่รู้ตัว
  </FeatureCard>
  <FeatureCard title="เปลี่ยนประเภทข้อมูลได้" icon="arrow-path">
    Shadowing สามารถเปลี่ยนประเภทข้อมูลของตัวแปรได้อย่างสมบูรณ์ แต่ `mut` ไม่สามารถทำได้! นี่คือข้อดีที่สำคัญที่สุดของ shadowing
  </FeatureCard>
</FeatureGrid>

<CodeExplainer title="ตัวอย่างเปลี่ยนประเภทข้อมูลด้วย Shadowing">
```rust
fn main() {
    let spaces = "   ";           // เป็น string (&str)
    let spaces = spaces.len();     // เปลี่ยนเป็นตัวเลข (usize)

    println!("จำนวนช่องว่าง: {}", spaces);
}
```
</CodeExplainer>

แต่ถ้าลองทำแบบนี้กับ `mut`:

<CodeExplainer title="โค้ดนี้จะ error แน่นอน">
```rust
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();  // error! ไม่สามารถเปลี่ยน string เป็นตัวเลขได้
}
```
</CodeExplainer>

```bash
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- ต้องการประเภท &str
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ แต่ได้รับประเภท usize
```

### กรณีที่ Shadowing มีประโยชน์จริงๆ

Shadowing มีประโยชน์มากในหลายสถานการณ์:

1. **การแปลงข้อมูลทีละขั้น:** เมื่อต้องการแปลงข้อมูลผ่านหลายขั้นตอน
2. **การปรับปรุงค่า:** เมื่อต้องการแก้ไขค่าแต่ยังคงชื่อเดิม
3. **การเปลี่ยนประเภทข้อมูล:** สำหรับการแปลงจากประเภทหนึ่งไปอีกประเภทหนึ่ง

<CodeExplainer title="ตัวอย่างการใช้ Shadowing ในชีวิตจริง">
```rust
fn main() {
    let configuration = "debug";
    let configuration = match configuration {
        "debug" => 0,
        "release" => 1,
        _ => 2,
    };
    println!("Configuration value: {}", configuration);
}
```
</CodeExplainer>

## การเลือกระหว่าง Immutable, Mutable และ Shadowing

ตอนนี้เรามีตัวเลือก 3 แบบในการจัดการตัวแปร แล้วเราจะเลือกใช้อย่างไร?

### กฎทั่วไปที่ควรคิดถึง:

1. **เริ่มต้นด้วย Immutable เสมอ** - เลือกใช้ `let` ปกติก่อนเสมอ
2. **ใช้ Mutable เมื่อจำเป็นจริงๆ** - เมื่อต้องการเปลี่ยนค่าบ่อยๆ ใน loop หรือ state machine
3. **ใช้ Shadowing เมื่อต้องการแปลงข้อมูล** - โดยเฉพาะเมื่อต้องเปลี่ยนประเภทข้อมูล

<FeatureGrid>
  <FeatureCard title="เมื่อไหร่ควรใช้ Immutable?" icon="check-circle">
    - ค่าที่ไม่ควรเปลี่ยนแปลง (ID, configuration)
    - ข้อมูลที่แชร์ระหว่าง thread ต่างๆ
    - ค่าคงที่ในฟังก์ชัน
    - ผลลัพธ์จากการคำนวณที่ไม่ต้องแก้ไข
  </FeatureCard>
  <FeatureCard title="เมื่อไหร่ควรใช้ Mutable?" icon="pencil-square">
    - Counter หรือ accumulator
    - State ที่เปลี่ยนแปลงตลอดเวลา
    - ข้อมูลที่ต้องอัปเดตบ่อยๆ
    - การเก็บข้อมูลที่รวบรวมจาก loop
  </FeatureCard>
  <FeatureCard title="เมื่อไหร่ควรใช้ Shadowing?" icon="square-2-stack">
    - การแปลงข้อมูลทีละขั้น
    - การเปลี่ยนประเภทข้อมูล
    - การปรับปรุงค่าจากข้อมูลเดิม
    - การคำนวณที่ซับซ้อน
  </FeatureCard>
</FeatureGrid>

## ตัวอย่างการประยุกต์ใช้ในชีวิตจริง

มาดูตัวอย่างการใช้งานจริงที่แสดงให้เห็นว่าแนวคิดเหล่านี้มีประโยชน์อย่างไร:

<CodeExplainer title="ตัวอย่าง: โปรแกรมคำนวณคะแนน">
```rust
const MAX_SCORE: u32 = 1000;
const BONUS_MULTIPLIER: f64 = 1.5;

fn calculate_final_score(base_score: u32, has_bonus: bool) -> u32 {
    let mut final_score = base_score;

    if has_bonus {
        final_score = (final_score as f64 * BONUS_MULTIPLIER) as u32;
    }

    // จำกัดคะแนนไม่ให้เกิน MAX_SCORE
    let final_score = if final_score > MAX_SCORE {
        MAX_SCORE
    } else {
        final_score
    };

    final_score
}

fn main() {
    let score1 = calculate_final_score(800, true);
    let score2 = calculate_final_score(600, false);

    println!("คะแนนสุดท้าย 1: {}", score1);
    println!("คะแนนสุดท้าย 2: {}", score2);
}
```
</CodeExplainer>

ในตัวอย่างนี้เราใช้:
- `const` สำหรับค่าคงที่ที่ใช้ทั่วโปรแกรม
- `mut` สำหรับตัวแปรที่ต้องเปลี่ยนค่าในฟังก์ชัน
- Shadowing สำหรับจำกัดค่าสูงสุดของคะแนน

## สรุปให้เข้าใจง่าย

<FeatureGrid>
  <FeatureCard title="ตัวแปรใน Rust" icon="cube">
    โดยค่าเริ่มต้นจะเปลี่ยนค่าไม่ได้ (immutable) ถ้าอยากเปลี่ยนก็ใส่ `mut` ไว้ข้างหน้า นี่คือวิธีที่ Rust ช่วยให้เราเขียนโค้ดที่ปลอดภัยขึ้น
  </FeatureCard>
  <FeatureCard title="ค่าคงที่" icon="lock-closed">
    ใช้ `const` ประกาศ ต้องระบุประเภทข้อมูลเสมอ และใช้ได้ทั่วทั้งโปรแกรม เหมาะสำหรับค่าที่ไม่เปลี่ยนแปลงตลอดเวลา
  </FeatureCard>
  <FeatureCard title="Shadowing" icon="square-2-stack">
    สามารถประกาศตัวแปรใหม่ด้วยชื่อเดิมได้ ดีตรงที่เปลี่ยนประเภทข้อมูลได้ และช่วยให้การแปลงข้อมูลทำได้ง่ายขึ้น
  </FeatureCard>
</FeatureGrid>

การเข้าใจเรื่องตัวแปรและการเปลี่ยนแปลงค่าเป็นพื้นฐานที่สำคัญมากใน Rust มันช่วยให้เราเขียนโค้ดที่ปลอดภัยและทำงานได้ดีขึ้น แม้ว่าในตอนแรกอาจจะรู้สึกแปลกๆ สำหรับคนที่มาจากภาษาอื่น แต่เมื่อคุณคุ้นเคยแล้ว คุณจะเห็นว่ามันช่วยป้องกันข้อผิดพลาดได้มากมาย

ในบทความหน้าเราจะมาเรียนรู้เรื่องประเภทข้อมูล (Data Types) ใน Rust กันต่อ ซึ่งเป็นอีกหัวข้อสำคัญที่จะช่วยให้เราเข้าใจวิธีการทำงานของ Rust ได้ลึกซึ้งยิ่งขึ้น

<InfoBox title="ลองเขียนเลย" type="success">
  สร้างโปรเจกต์ใหม่ด้วย `cargo new variables` แล้วลองเขียนโค้ดจากตัวอย่างดูนะครับ การลองทำด้วยมือจะช่วยให้คุณเข้าใจได้ดีกว่าอ่านอย่างเดียวเยอะ และอย่าลืมลองทำให้คอมไพล์ผิดดูด้วย เพื่อเห็นว่า Rust ช่วยเราได้อย่างไร!
</InfoBox>
